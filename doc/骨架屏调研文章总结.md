# 骨架屏调研文章总结

## 如何让你的网页“看起来”展现地更快 —— 骨架屏二三事

https://juejin.im/post/6844903744740524039

### 小概念

- 首屏时间FP
- FCP：页面有效内容的绘制
- FMP：页面有意义内容的绘制

### 骨架屏的优势

- 1. 在页面加载初期预先渲染内容，提升感官体验
- 2. 只需要简单的CSS和js支持，不需要https协议

  这里用到js的原因是，涉及到图片的懒加载，或者是销毁骨架屏代码等

- 3. 如果页面采用组件开发，每个组件可以根据自身状态定义自身的骨架屏以及切换实际，可以维护组件之间的独立性

  这点，暂时还没有实现呀

### 使用场景

- SPA和MPA
- 现有的web渲染模式

	- 前端渲染

		- 服务端返回一个固定的HTML，这个HTML通常会包含一个占位的空节点，前端经过一系列的操作把页面内容渲染进行，在渲染之前，骨架屏是个很好的替补队员
		- 存在SEO不友好的问题

			- 解决方案：SSR

	- 后端渲染

		- 服务端直接返回网站的HTML页面，包含首页的绝大多数DOM元素以及绑定事件等

### 实现思路

- 1. 在index.html模板中的#app下面加入骨架屏的HTML代码

  这个HTML可以是base64的静态图片，也可以是简单的CSS代码

- 2. 在执行JS开始真正内容的渲染之前，清空骨架屏的HTML代码

  以Vue为例，在mount挂载之前清空即可
  ```js
  let app = new Vue({...})
  let container = document.querySelector('#app')
  if (container) {
    container.innerHTML = ''
  }
  app.$mount(container)
  ```

### 需要注意的点

- 1. 浏览器的重排

  每个CSS的加载都可能会触发重排或者重绘， 基于这一点，浏览器会等待HTML中所有的CSS都加载完成，注册完，一起应用样式，力求一次完成排列工作，不要出现反复的重排

- 2. preload

  浏览器还提供了其他一些机制确保（后续）页面的性能，我们称之为 preload，中文叫预加载。具体来说，使用 <link rel="preload" href="xxxx">，提前把后续要使用的资源先声明一下。在浏览器空闲的时候会提前加载并放入缓存。之后再使用就可以节省一个网络请求
  
  预加载的资源是不会影响当前页面的

	- 预加载的请求不会影响当前页面

	  <link rel="preload" href="index.css" as="style" onload="this.rel='stylesheet'">
	  
	  css加载完之后修改了自己的rel属性，
	  然而有些浏览器会在rel改变时，重新触发onload：为了消除这个影响，我们再在 onload 里面添加一句 this.onload=null
	  
	  最终：<link rel="preload" href="index.css" as="style" onload="this.onload=null;this.rel='stylesheet';window.STYLE_READY=true;window.mountApp && window.mountApp()">
	  
	  <!-- 为了方便阅读，折行重复一遍 -->
	  <!-- this.onload=null -->
	  <!-- this.rel='stylesheet' -->
	  <!-- window.STYLE_READY=true -->
	  <!-- window.mountApp && window.mountApp() -->

	- 兼容性不太行，需要polyfill

- 3. 渲染的顺序

	- 严格控制css早于js渲染

	  <link rel="preload" href="index.css" as="style" onload="this.rel='stylesheet';window.STYLE_READY=true;window.mountApp && window.mountApp()">

### 多骨架屏页面的支持

在单页面应用中，只有一个index.html，所有的变化都是由前端在容器节点的内部进行更改的，所以，如果我们直接在index.html中注入了骨架屏的代码，那么这个应用内的所有页面都会有同样的骨架屏，这样骨架屏的作用就和loading类似了

- 1. 把所有种类的骨架屏的HTML和样式全部写入到index.html中
- 2.  在index.html的地步新增script脚本，根据当前的路由判断加载哪一个骨架屏，但是这样会导致index.html的体积变大

### 结论

- 是在vue-skeleton-webpack-plugin的基础上做的修改

	- 所以他推荐的是vue-skeleton-webpack-plugin

- 核心做法是：修改模板index.html中的占位容器，保证在页面需要的css和js加载之前，加载骨架屏
- 代码手写的，推荐练手

## 一种对开发更友好的前端骨架屏自动生成方案

https://juejin.im/post/6844903936613171213

### 小概念

- 用户调研表示，页面加载不要超过2s

### 优势

- 1. 优化交互，避免长时间空白
- 2. 获知页面大体结构，减少用户认为出错而导致离开页面的几率
- 3. 与传统loading相比，更加流畅

### 常见的骨架屏方案

- 1. UI骨架屏图，比如小米的首页
- 2. 手写HTML，CSS定制骨架屏
- 3. 自动生成静态骨架屏：page-skeleton-webpack-plugin

  通过puppeteer生成，在构建时注入模板中节点下面。可以根据不同的路由生成响应的骨架屏页面
  但是只支持history模式和首页，但是在实际的应用中发现，也支持hash的路由

- 4. draw-page-structure

  做法：
  根据URL指定的线上地址，配合puppeteer获取当前页面的DOM结构，并对元素节点生成骨架屏文件添加到指定的文件中的某个节点下【其实和page-skeleton-webpack-plugin很类似】
  缺点：
  不支持开发环境，只能用线上的URL生成
  当页面存在重定向时，如未登录，则会生成的页面与预期的效果不一样

### 实现方案

## 每天一点网站优化之：给vue应用添加骨架屏

https://juejin.im/post/6844903939167485960#heading-5

## page-skeleton骨架屏的实现

https://juejin.im/post/6847902219509956616#heading-6

## 引入骨架屏生成工具实践

https://juejin.im/post/6844904198367084552#heading-7

## 使用Chrome扩展程序生成网页骨架屏

https://juejin.im/post/6856784900775739400#heading-4

## 网页骨架屏自动生成方案（dps）

https://juejin.im/post/6844903893525069838#heading-5

## CSS实现Skeleton Screen（骨架屏）

https://juejin.im/post/6844904186832748557

## 自动生成跨多端骨架屏

https://juejin.im/post/6844903846553059336

## skeleton 骨架屏VV-UI

https://vv-ui.github.io/VV-UI/#/skeleton

## 骨架屏技术讲解以及如何在Vue中实现骨架屏

https://juejin.im/post/6844904126472699911#heading-7

## Vue 页面骨架屏注入实践

https://juejin.im/post/6844903773605740558

## awesome skeleton

https://github.com/kaola-fed/awesome-skeleton#readme

## 2020-03-26 考拉前端骨架屏生成技术揭秘

https://www.jianshu.com/p/084cab297a2a

## 结合项目来谈谈 Puppeteer

https://zhuanlan.zhihu.com/p/76237595

## Puppeteer 指南

https://blog.xcatliu.com/2018/09/18/puppeteer_tutorial/

## Puppeteer

https://pptr.dev/#?product=Puppeteer&version=v5.2.1

